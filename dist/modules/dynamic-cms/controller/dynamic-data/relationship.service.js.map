{"version":3,"sources":["../../../../../src/modules/dynamic-cms/controller/dynamic-data/relationship.service.ts"],"sourcesContent":["import { Injectable, NotFoundException } from '@nestjs/common';\r\nimport { InjectModel } from '@nestjs/mongoose';\r\nimport { Model, Types } from 'mongoose';\r\nimport {\r\n  DynamicData,\r\n  DynamicDataDocument,\r\n} from '../../schemas/dynamic-data.schema';\r\nimport { CollectionSchemaService } from '../collection-schema/collection-schema.service';\r\nimport {\r\n  FieldType,\r\n  RelationType,\r\n} from '../../interfaces/field-types.interface';\r\n\r\n@Injectable()\r\nexport class RelationshipService {\r\n  constructor(\r\n    @InjectModel(DynamicData.name)\r\n    private dynamicDataModel: Model<DynamicDataDocument>,\r\n    private collectionSchemaService: CollectionSchemaService,\r\n  ) {}\r\n\r\n  /**\r\n   * Populate references trong document\r\n   */\r\n  async populateDocument(\r\n    collectionName: string,\r\n    databaseId: string,\r\n    document: any,\r\n    depth: number = 1,\r\n    visitedCollections: Set<string> = new Set(),\r\n  ): Promise<any> {\r\n    if (depth <= 0) return document;\r\n    if (visitedCollections.has(collectionName)) return document; // Tránh circular reference\r\n\r\n    visitedCollections.add(collectionName);\r\n\r\n    const schema = await this.collectionSchemaService.findByNamePublic(\r\n      collectionName,\r\n      databaseId,\r\n    );\r\n\r\n    if (!schema) return document;\r\n\r\n    const plainDoc = document.toObject ? document.toObject() : document;\r\n    const { _data, ...rest } = plainDoc;\r\n    const populatedData = { ..._data };\r\n\r\n    // Tìm các field có type REFERENCE\r\n    const referenceFields = schema.fields.filter(\r\n      (field) => field.type === FieldType.REFERENCE && field.referenceConfig,\r\n    );\r\n\r\n    for (const field of referenceFields) {\r\n      const refConfig = field.referenceConfig!;\r\n      const fieldValue = _data[field.name];\r\n\r\n      if (!fieldValue) continue;\r\n\r\n      // Kiểm tra autoPopulate\r\n      if (refConfig.autoPopulate === false) continue;\r\n\r\n      try {\r\n        if (refConfig.multiple && Array.isArray(fieldValue)) {\r\n          // Multiple references\r\n          const populated = await this.populateMultipleReferences(\r\n            refConfig.collection,\r\n            databaseId,\r\n            fieldValue,\r\n            refConfig.populateFields,\r\n            depth - 1,\r\n            new Set(visitedCollections),\r\n          );\r\n          populatedData[field.name] = populated;\r\n        } else if (!Array.isArray(fieldValue)) {\r\n          // Single reference\r\n          const populated = await this.populateSingleReference(\r\n            refConfig.collection,\r\n            databaseId,\r\n            fieldValue,\r\n            refConfig.populateFields,\r\n            depth - 1,\r\n            new Set(visitedCollections),\r\n          );\r\n          populatedData[field.name] = populated;\r\n        }\r\n      } catch (error) {\r\n        console.error(`Error populating field ${field.name}:`, error.message);\r\n        // Giữ nguyên giá trị gốc nếu populate lỗi\r\n      }\r\n    }\r\n\r\n    return {\r\n      ...rest,\r\n      ...populatedData,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Populate multiple documents\r\n   */\r\n  async populateDocuments(\r\n    collectionName: string,\r\n    databaseId: string,\r\n    documents: any[],\r\n    depth: number = 1,\r\n  ): Promise<any[]> {\r\n    const visitedCollections = new Set<string>();\r\n    return Promise.all(\r\n      documents.map((doc) =>\r\n        this.populateDocument(\r\n          collectionName,\r\n          databaseId,\r\n          doc,\r\n          depth,\r\n          new Set(visitedCollections),\r\n        ),\r\n      ),\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Populate single reference\r\n   */\r\n  private async populateSingleReference(\r\n    collectionName: string,\r\n    databaseId: string,\r\n    refId: string,\r\n    fields?: string[],\r\n    depth: number = 0,\r\n    visitedCollections: Set<string> = new Set(),\r\n  ): Promise<any> {\r\n    try {\r\n      const objectId = new Types.ObjectId(refId);\r\n      const doc = await this.dynamicDataModel.findOne({\r\n        _id: objectId,\r\n        _collection: collectionName,\r\n        databaseId: new Types.ObjectId(databaseId),\r\n        deletedAt: null,\r\n      });\r\n\r\n      if (!doc) return null;\r\n\r\n      // Nếu có chỉ định fields cụ thể\r\n      let result: any;\r\n      if (fields && fields.length > 0) {\r\n        result = { _id: doc._id };\r\n        fields.forEach((field) => {\r\n          if (doc._data[field] !== undefined) {\r\n            result[field] = doc._data[field];\r\n          }\r\n        });\r\n      } else {\r\n        result = doc.toObject();\r\n        const { _data, ...rest } = result;\r\n        result = { ...rest, ..._data };\r\n      }\r\n\r\n      // Populate nested references nếu depth > 0\r\n      if (depth > 0) {\r\n        return this.populateDocument(\r\n          collectionName,\r\n          databaseId,\r\n          result,\r\n          depth,\r\n          visitedCollections,\r\n        );\r\n      }\r\n\r\n      return result;\r\n    } catch (error) {\r\n      console.error('Error populating single reference:', error.message);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Populate multiple references\r\n   */\r\n  private async populateMultipleReferences(\r\n    collectionName: string,\r\n    databaseId: string,\r\n    refIds: string[],\r\n    fields?: string[],\r\n    depth: number = 0,\r\n    visitedCollections: Set<string> = new Set(),\r\n  ): Promise<any[]> {\r\n    try {\r\n      const objectIds = refIds\r\n        .filter((id) => Types.ObjectId.isValid(id))\r\n        .map((id) => new Types.ObjectId(id));\r\n\r\n      if (objectIds.length === 0) return [];\r\n\r\n      const docs = await this.dynamicDataModel.find({\r\n        _id: { $in: objectIds },\r\n        _collection: collectionName,\r\n        databaseId: new Types.ObjectId(databaseId),\r\n        deletedAt: null,\r\n      });\r\n\r\n      // Transform và filter fields\r\n      let results = docs.map((doc) => {\r\n        if (fields && fields.length > 0) {\r\n          const result: any = { _id: doc._id };\r\n          fields.forEach((field) => {\r\n            if (doc._data[field] !== undefined) {\r\n              result[field] = doc._data[field];\r\n            }\r\n          });\r\n          return result;\r\n        } else {\r\n          const plainDoc = doc.toObject();\r\n          const { _data, ...rest } = plainDoc;\r\n          return { ...rest, ..._data };\r\n        }\r\n      });\r\n\r\n      // Populate nested references nếu depth > 0\r\n      if (depth > 0) {\r\n        results = await Promise.all(\r\n          results.map((result) =>\r\n            this.populateDocument(\r\n              collectionName,\r\n              databaseId,\r\n              result,\r\n              depth,\r\n              visitedCollections,\r\n            ),\r\n          ),\r\n        );\r\n      }\r\n\r\n      return results;\r\n    } catch (error) {\r\n      console.error('Error populating multiple references:', error.message);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Validate reference ID exists\r\n   */\r\n  async validateReference(\r\n    collectionName: string,\r\n    databaseId: string,\r\n    refId: string,\r\n  ): Promise<boolean> {\r\n    try {\r\n      const objectId = new Types.ObjectId(refId);\r\n      const exists = await this.dynamicDataModel.exists({\r\n        _id: objectId,\r\n        _collection: collectionName,\r\n        databaseId: new Types.ObjectId(databaseId),\r\n        deletedAt: null,\r\n      });\r\n      return !!exists;\r\n    } catch (error) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Validate multiple references\r\n   */\r\n  async validateReferences(\r\n    collectionName: string,\r\n    databaseId: string,\r\n    refIds: string[],\r\n  ): Promise<{ valid: boolean; invalidIds: string[] }> {\r\n    const invalidIds: string[] = [];\r\n\r\n    for (const refId of refIds) {\r\n      const isValid = await this.validateReference(\r\n        collectionName,\r\n        databaseId,\r\n        refId,\r\n      );\r\n      if (!isValid) {\r\n        invalidIds.push(refId);\r\n      }\r\n    }\r\n\r\n    return {\r\n      valid: invalidIds.length === 0,\r\n      invalidIds,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get inverse relationships (tìm tất cả documents reference đến document này)\r\n   */\r\n  async getInverseRelations(\r\n    collectionName: string,\r\n    databaseId: string,\r\n    documentId: string,\r\n    inverseCollectionName: string,\r\n    inverseFieldName: string,\r\n  ): Promise<any[]> {\r\n    try {\r\n      const docs = await this.dynamicDataModel.find({\r\n        _collection: inverseCollectionName,\r\n        databaseId: new Types.ObjectId(databaseId),\r\n        [`_data.${inverseFieldName}`]: documentId,\r\n        deletedAt: null,\r\n      });\r\n\r\n      return docs.map((doc) => {\r\n        const plainDoc = doc.toObject();\r\n        const { _data, ...rest } = plainDoc;\r\n        return { ...rest, ..._data };\r\n      });\r\n    } catch (error) {\r\n      console.error('Error getting inverse relations:', error.message);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Cascade delete references khi xóa document\r\n   */\r\n  async cascadeDelete(\r\n    collectionName: string,\r\n    databaseId: string,\r\n    documentId: string,\r\n  ): Promise<void> {\r\n    const schema = await this.collectionSchemaService.findByNamePublic(\r\n      collectionName,\r\n      databaseId,\r\n    );\r\n\r\n    if (!schema) return;\r\n\r\n    // Tìm các field có cascadeDelete = true\r\n    const cascadeFields = schema.fields.filter(\r\n      (field) =>\r\n        field.type === FieldType.REFERENCE &&\r\n        field.referenceConfig?.cascadeDelete,\r\n    );\r\n\r\n    for (const field of cascadeFields) {\r\n      const refConfig = field.referenceConfig!;\r\n      const doc = await this.dynamicDataModel.findOne({\r\n        _id: new Types.ObjectId(documentId),\r\n        _collection: collectionName,\r\n        databaseId: new Types.ObjectId(databaseId),\r\n      });\r\n\r\n      if (!doc) continue;\r\n\r\n      const refValue = doc._data[field.name];\r\n      if (!refValue) continue;\r\n\r\n      try {\r\n        if (refConfig.multiple && Array.isArray(refValue)) {\r\n          // Xóa multiple references\r\n          await this.dynamicDataModel.deleteMany({\r\n            _id: { $in: refValue.map((id) => new Types.ObjectId(id)) },\r\n            _collection: refConfig.collection,\r\n            databaseId: new Types.ObjectId(databaseId),\r\n          });\r\n        } else if (!Array.isArray(refValue)) {\r\n          // Xóa single reference\r\n          await this.dynamicDataModel.deleteOne({\r\n            _id: new Types.ObjectId(refValue),\r\n            _collection: refConfig.collection,\r\n            databaseId: new Types.ObjectId(databaseId),\r\n          });\r\n        }\r\n      } catch (error) {\r\n        console.error(\r\n          `Error cascade deleting field ${field.name}:`,\r\n          error.message,\r\n        );\r\n      }\r\n    }\r\n  }\r\n}\r\n"],"names":["RelationshipService","populateDocument","collectionName","databaseId","document","depth","visitedCollections","Set","has","add","schema","collectionSchemaService","findByNamePublic","plainDoc","toObject","_data","rest","populatedData","referenceFields","fields","filter","field","type","FieldType","REFERENCE","referenceConfig","refConfig","fieldValue","name","autoPopulate","multiple","Array","isArray","populated","populateMultipleReferences","collection","populateFields","populateSingleReference","error","console","message","populateDocuments","documents","Promise","all","map","doc","refId","objectId","Types","ObjectId","dynamicDataModel","findOne","_id","_collection","deletedAt","result","length","forEach","undefined","refIds","objectIds","id","isValid","docs","find","$in","results","validateReference","exists","validateReferences","invalidIds","push","valid","getInverseRelations","documentId","inverseCollectionName","inverseFieldName","cascadeDelete","cascadeFields","refValue","deleteMany","deleteOne"],"mappings":"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"}