{"version":3,"sources":["../../../../../src/modules/dynamic-cms/controller/collection-schema/collection-schema.service.ts"],"sourcesContent":["import {\r\n  Injectable,\r\n  BadRequestException,\r\n  NotFoundException,\r\n  ForbiddenException,\r\n} from '@nestjs/common';\r\nimport { InjectModel } from '@nestjs/mongoose';\r\nimport { Model, Types } from 'mongoose';\r\nimport {\r\n  CollectionSchemaModel,\r\n  CollectionSchemaDocument,\r\n} from '../../schemas/collection-schema.schema';\r\nimport {\r\n  CreateCollectionSchemaDto,\r\n  UpdateCollectionSchemaDto,\r\n} from '../../dto/collection-schema.dto';\r\nimport {\r\n  PaginationDto,\r\n  PaginationResponse,\r\n} from '../../../../common/dto/pagination.dto';\r\nimport { FieldType } from '../../interfaces/field-types.interface';\r\nimport {\r\n  ValidationResponse,\r\n  ValidationError,\r\n  createValidationError,\r\n  createValidationResponse,\r\n} from '../../../../common/dto/validation.dto';\r\n\r\n@Injectable()\r\nexport class CollectionSchemaService {\r\n  constructor(\r\n    @InjectModel(CollectionSchemaModel.name)\r\n    private collectionSchemaModel: Model<CollectionSchemaDocument>,\r\n  ) {}\r\n\r\n  /**\r\n   * Tạo collection schema mới\r\n   */\r\n  async create(\r\n    createDto: CreateCollectionSchemaDto,\r\n    userId: string,\r\n  ): Promise<CollectionSchemaModel> {\r\n    // Kiểm tra xem collection name đã tồn tại trong database này chưa\r\n    const existing = await this.collectionSchemaModel\r\n      .findOne({\r\n        databaseId: new Types.ObjectId(createDto.databaseId),\r\n        name: createDto.name,\r\n      })\r\n      .exec();\r\n\r\n    if (existing) {\r\n      throw new BadRequestException(\r\n        `Collection with name \"${createDto.name}\" already exists in this database`,\r\n      );\r\n    }\r\n\r\n    // Validate field names không trùng nhau\r\n    const fieldNames = createDto.fields.map((f) => f.name);\r\n    const uniqueNames = new Set(fieldNames);\r\n    if (fieldNames.length !== uniqueNames.size) {\r\n      throw new BadRequestException('Field names must be unique');\r\n    }\r\n\r\n    // Tạo collection schema\r\n    const schema = new this.collectionSchemaModel({\r\n      ...createDto,\r\n      databaseId: new Types.ObjectId(createDto.databaseId),\r\n      userId: new Types.ObjectId(userId),\r\n      createdBy: userId,\r\n      version: 1,\r\n    });\r\n\r\n    return schema.save();\r\n  }\r\n\r\n  /**\r\n   * Lấy danh sách collection schemas của user trong database\r\n   */\r\n  async findAll(\r\n    paginationDto: PaginationDto,\r\n    userId: string,\r\n    databaseId?: string,\r\n  ): Promise<PaginationResponse<CollectionSchemaModel>> {\r\n    const { page = 1, limit = 10, search } = paginationDto;\r\n    const skip = (page - 1) * limit;\r\n\r\n    const query: any = { userId: new Types.ObjectId(userId) };\r\n\r\n    if (databaseId) {\r\n      query.databaseId = new Types.ObjectId(databaseId);\r\n    }\r\n\r\n    if (search) {\r\n      query.$or = [\r\n        { name: { $regex: search, $options: 'i' } },\r\n        { displayName: { $regex: search, $options: 'i' } },\r\n        { description: { $regex: search, $options: 'i' } },\r\n      ];\r\n    }\r\n\r\n    const [data, total] = await Promise.all([\r\n      this.collectionSchemaModel\r\n        .find(query)\r\n        .skip(skip)\r\n        .limit(limit)\r\n        .sort({ createdAt: -1 })\r\n        .exec(),\r\n      this.collectionSchemaModel.countDocuments(query).exec(),\r\n    ]);\r\n\r\n    return {\r\n      data,\r\n      total,\r\n      page,\r\n      limit,\r\n      totalPages: Math.ceil(total / limit),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Lấy collection schema theo ID và kiểm tra ownership\r\n   */\r\n  async findById(\r\n    id: string,\r\n    userId: string,\r\n  ): Promise<CollectionSchemaModel | null> {\r\n    const schema = await this.collectionSchemaModel.findById(id).exec();\r\n\r\n    if (!schema) {\r\n      throw new NotFoundException(\r\n        `Collection schema with id \"${id}\" not found`,\r\n      );\r\n    }\r\n\r\n    if (schema.userId.toString() !== userId) {\r\n      throw new ForbiddenException('You do not have access to this collection');\r\n    }\r\n\r\n    return schema;\r\n  }\r\n\r\n  /**\r\n   * Lấy collection schema theo name trong database của user (có check ownership)\r\n   */\r\n  async findByName(\r\n    name: string,\r\n    userId: string,\r\n    databaseId: string,\r\n  ): Promise<CollectionSchemaModel | null> {\r\n    return this.collectionSchemaModel\r\n      .findOne({\r\n        name,\r\n        userId: new Types.ObjectId(userId),\r\n        databaseId: new Types.ObjectId(databaseId),\r\n      })\r\n      .exec();\r\n  }\r\n\r\n  /**\r\n   * Lấy collection schema theo name trong database (không check ownership)\r\n   * Dùng cho public API - chỉ cần databaseId\r\n   */\r\n  async findByNamePublic(\r\n    name: string,\r\n    databaseId: string,\r\n  ): Promise<CollectionSchemaModel | null> {\r\n    return this.collectionSchemaModel\r\n      .findOne({\r\n        name,\r\n        databaseId: new Types.ObjectId(databaseId),\r\n      })\r\n      .exec();\r\n  }\r\n\r\n  /**\r\n   * Lấy tất cả collection schemas của user (không phân trang)\r\n   */\r\n  async findAllSchemas(\r\n    userId: string,\r\n    databaseId?: string,\r\n  ): Promise<CollectionSchemaModel[]> {\r\n    const query: any = { userId: new Types.ObjectId(userId) };\r\n\r\n    if (databaseId) {\r\n      query.databaseId = new Types.ObjectId(databaseId);\r\n    }\r\n\r\n    return this.collectionSchemaModel\r\n      .find(query)\r\n      .select('-fields')\r\n      .sort({ displayName: 1 })\r\n      .exec();\r\n  }\r\n\r\n  /**\r\n   * Cập nhật collection schema\r\n   */\r\n  async update(\r\n    id: string,\r\n    updateDto: UpdateCollectionSchemaDto,\r\n    userId: string,\r\n  ): Promise<CollectionSchemaModel | null> {\r\n    const schema = await this.collectionSchemaModel.findById(id).exec();\r\n\r\n    if (!schema) {\r\n      throw new NotFoundException(\r\n        `Collection schema with id \"${id}\" not found`,\r\n      );\r\n    }\r\n\r\n    // Check ownership\r\n    if (schema.userId.toString() !== userId) {\r\n      throw new ForbiddenException('You do not have access to this collection');\r\n    }\r\n\r\n    // Nếu update fields, validate field names\r\n    if (updateDto.fields) {\r\n      const fieldNames = updateDto.fields.map((f) => f.name);\r\n      const uniqueNames = new Set(fieldNames);\r\n      if (fieldNames.length !== uniqueNames.size) {\r\n        throw new BadRequestException('Field names must be unique');\r\n      }\r\n    }\r\n\r\n    // Tăng version khi update\r\n    const updatedSchema = await this.collectionSchemaModel\r\n      .findByIdAndUpdate(\r\n        id,\r\n        {\r\n          ...updateDto,\r\n          version: schema.version + 1,\r\n        },\r\n        { new: true },\r\n      )\r\n      .exec();\r\n\r\n    return updatedSchema;\r\n  }\r\n\r\n  /**\r\n   * Xóa collection schema\r\n   */\r\n  async remove(\r\n    id: string,\r\n    userId: string,\r\n  ): Promise<CollectionSchemaModel | null> {\r\n    const schema = await this.collectionSchemaModel.findById(id).exec();\r\n\r\n    if (!schema) {\r\n      throw new NotFoundException(\r\n        `Collection schema with id \"${id}\" not found`,\r\n      );\r\n    }\r\n\r\n    // Check ownership\r\n    if (schema.userId.toString() !== userId) {\r\n      throw new ForbiddenException('You do not have access to this collection');\r\n    }\r\n\r\n    // TODO: Kiểm tra xem có dữ liệu nào đang sử dụng schema này không\r\n    // Nếu có thì cần warning hoặc không cho xóa\r\n\r\n    return this.collectionSchemaModel.findByIdAndDelete(id).exec();\r\n  }\r\n\r\n  /**\r\n   * Validate dữ liệu theo schema\r\n   */\r\n  async validateData(\r\n    collectionName: string,\r\n    userId: string | null,\r\n    databaseId: string,\r\n    data: Record<string, any>,\r\n  ): Promise<ValidationResponse> {\r\n    const errors: ValidationError[] = [];\r\n\r\n    // Lấy schema\r\n    const schema = await this.findByName(collectionName, userId, databaseId);\r\n    if (!schema) {\r\n      throw new NotFoundException(\r\n        `Collection schema \"${collectionName}\" not found`,\r\n      );\r\n    }\r\n\r\n    // Danh sách các field tự động của hệ thống - không cần validate\r\n    const systemFields = ['id', '_id', 'createdAt', 'updatedAt', '__v'];\r\n\r\n    // Validate từng field\r\n    for (const field of schema.fields) {\r\n      // Bỏ qua các field hệ thống\r\n      if (systemFields.includes(field.name)) {\r\n        continue;\r\n      }\r\n\r\n      const value = data[field.name];\r\n      const validation = field.validation || {};\r\n\r\n      // Check required\r\n      if (\r\n        validation.required &&\r\n        (value === undefined || value === null || value === '')\r\n      ) {\r\n        errors.push(\r\n          createValidationError(\r\n            field.name,\r\n            `${field.label || field.name} is required`,\r\n          ),\r\n        );\r\n        continue;\r\n      }\r\n\r\n      // Nếu không có value và không required thì skip validation type\r\n      if (value === undefined || value === null) {\r\n        continue;\r\n      }\r\n\r\n      // Validate type\r\n      const actualType = typeof value;\r\n      let isValidType = false;\r\n\r\n      switch (field.type) {\r\n        case FieldType.STRING:\r\n        case FieldType.TEXT:\r\n        case FieldType.TEXTAREA:\r\n        case FieldType.EMAIL:\r\n        case FieldType.URL:\r\n        case FieldType.RICH_TEXT:\r\n          isValidType = actualType === 'string';\r\n          break;\r\n        case FieldType.NUMBER:\r\n          isValidType = actualType === 'number' && !isNaN(value);\r\n          break;\r\n        case FieldType.BOOLEAN:\r\n        case FieldType.CHECKBOX:\r\n          isValidType = actualType === 'boolean';\r\n          break;\r\n        case FieldType.DATE:\r\n        case FieldType.DATETIME:\r\n          isValidType = !isNaN(Date.parse(value));\r\n          break;\r\n        case FieldType.ARRAY:\r\n        case FieldType.MULTI_SELECT:\r\n          isValidType = Array.isArray(value);\r\n          break;\r\n        case FieldType.JSON:\r\n          isValidType = actualType === 'object' && !Array.isArray(value);\r\n          break;\r\n        case FieldType.REFERENCE:\r\n          // Reference có thể là ObjectId hoặc string\r\n          isValidType =\r\n            actualType === 'string' || Types.ObjectId.isValid(value);\r\n          break;\r\n        case FieldType.SELECT:\r\n        case FieldType.RADIO:\r\n          isValidType = actualType === 'string' || actualType === 'number';\r\n          break;\r\n        case FieldType.FILE:\r\n        case FieldType.IMAGE:\r\n          isValidType = actualType === 'string'; // URL string\r\n          break;\r\n        default:\r\n          isValidType = true; // Unknown types pass\r\n      }\r\n\r\n      if (!isValidType) {\r\n        errors.push(\r\n          createValidationError(\r\n            field.name,\r\n            `${field.label || field.name} must be of type ${field.type}, got ${actualType}`,\r\n          ),\r\n        );\r\n      }\r\n\r\n      // Validate enum\r\n      if (validation.enum && validation.enum.length > 0) {\r\n        if (!validation.enum.includes(value)) {\r\n          errors.push(\r\n            createValidationError(\r\n              field.name,\r\n              `${field.label || field.name} must be one of: ${validation.enum.join(', ')}`,\r\n            ),\r\n          );\r\n        }\r\n      }\r\n\r\n      // Validate min/max for numbers\r\n      if (field.type === FieldType.NUMBER && typeof value === 'number') {\r\n        if (validation.min !== undefined && value < validation.min) {\r\n          errors.push(\r\n            createValidationError(\r\n              field.name,\r\n              `${field.label || field.name} must be at least ${validation.min}`,\r\n            ),\r\n          );\r\n        }\r\n        if (validation.max !== undefined && value > validation.max) {\r\n          errors.push(\r\n            createValidationError(\r\n              field.name,\r\n              `${field.label || field.name} must be at most ${validation.max}`,\r\n            ),\r\n          );\r\n        }\r\n      }\r\n\r\n      // Validate minLength/maxLength for strings\r\n      if (\r\n        (field.type === FieldType.STRING ||\r\n          field.type === FieldType.TEXT ||\r\n          field.type === FieldType.TEXTAREA) &&\r\n        typeof value === 'string'\r\n      ) {\r\n        if (\r\n          validation.minLength !== undefined &&\r\n          value.length < validation.minLength\r\n        ) {\r\n          errors.push(\r\n            createValidationError(\r\n              field.name,\r\n              `${field.label || field.name} must be at least ${validation.minLength} characters`,\r\n            ),\r\n          );\r\n        }\r\n        if (\r\n          validation.maxLength !== undefined &&\r\n          value.length > validation.maxLength\r\n        ) {\r\n          errors.push(\r\n            createValidationError(\r\n              field.name,\r\n              `${field.label || field.name} must be at most ${validation.maxLength} characters`,\r\n            ),\r\n          );\r\n        }\r\n      }\r\n\r\n      // Validate pattern (regex)\r\n      if (validation.pattern && typeof value === 'string') {\r\n        const regex = new RegExp(validation.pattern);\r\n        if (!regex.test(value)) {\r\n          errors.push(\r\n            createValidationError(\r\n              field.name,\r\n              `${field.label || field.name} does not match the required pattern`,\r\n            ),\r\n          );\r\n        }\r\n      }\r\n\r\n      // TODO: Validate unique\r\n      // Cần inject DynamicDataModel để check uniqueness trong database\r\n    }\r\n\r\n    return createValidationResponse(errors);\r\n  }\r\n\r\n  /**\r\n   * Validate dữ liệu theo schema (public - không check ownership)\r\n   * Dùng cho dynamic-data public API\r\n   */\r\n  async validateDataPublic(\r\n    collectionName: string,\r\n    databaseId: string,\r\n    data: Record<string, any>,\r\n  ): Promise<ValidationResponse> {\r\n    const errors: ValidationError[] = [];\r\n\r\n    // Lấy schema (không check ownership)\r\n    const schema = await this.findByNamePublic(collectionName, databaseId);\r\n    if (!schema) {\r\n      throw new NotFoundException(\r\n        `Collection schema \"${collectionName}\" not found`,\r\n      );\r\n    }\r\n\r\n    // Danh sách các field tự động của hệ thống - không cần validate\r\n    const systemFields = ['id', '_id', 'createdAt', 'updatedAt', '__v'];\r\n\r\n    // Validate từng field\r\n    for (const field of schema.fields) {\r\n      // Bỏ qua các field hệ thống\r\n      if (systemFields.includes(field.name)) {\r\n        continue;\r\n      }\r\n\r\n      const value = data[field.name];\r\n      const validation = field.validation || {};\r\n\r\n      // Check required\r\n      if (\r\n        validation.required &&\r\n        (value === undefined || value === null || value === '')\r\n      ) {\r\n        errors.push(\r\n          createValidationError(\r\n            field.name,\r\n            `${field.label || field.name} is required`,\r\n          ),\r\n        );\r\n        continue; // Bỏ qua các validation khác nếu required fail\r\n      }\r\n\r\n      // Nếu value không có và không required thì skip validation\r\n      if (value === undefined || value === null) {\r\n        continue;\r\n      }\r\n\r\n      // Validate min/max for numbers\r\n      if (field.type === FieldType.NUMBER && typeof value === 'number') {\r\n        if (validation.min !== undefined && value < validation.min) {\r\n          errors.push(\r\n            createValidationError(\r\n              field.name,\r\n              `${field.label || field.name} must be at least ${validation.min}`,\r\n            ),\r\n          );\r\n        }\r\n        if (validation.max !== undefined && value > validation.max) {\r\n          errors.push(\r\n            createValidationError(\r\n              field.name,\r\n              `${field.label || field.name} must be at most ${validation.max}`,\r\n            ),\r\n          );\r\n        }\r\n      }\r\n\r\n      // Validate minLength/maxLength for strings\r\n      if (\r\n        (field.type === FieldType.STRING ||\r\n          field.type === FieldType.TEXT ||\r\n          field.type === FieldType.TEXTAREA) &&\r\n        typeof value === 'string'\r\n      ) {\r\n        if (\r\n          validation.minLength !== undefined &&\r\n          value.length < validation.minLength\r\n        ) {\r\n          errors.push(\r\n            createValidationError(\r\n              field.name,\r\n              `${field.label || field.name} must be at least ${validation.minLength} characters`,\r\n            ),\r\n          );\r\n        }\r\n        if (\r\n          validation.maxLength !== undefined &&\r\n          value.length > validation.maxLength\r\n        ) {\r\n          errors.push(\r\n            createValidationError(\r\n              field.name,\r\n              `${field.label || field.name} must be at most ${validation.maxLength} characters`,\r\n            ),\r\n          );\r\n        }\r\n      }\r\n\r\n      // Validate pattern (regex)\r\n      if (validation.pattern && typeof value === 'string') {\r\n        const regex = new RegExp(validation.pattern);\r\n        if (!regex.test(value)) {\r\n          errors.push(\r\n            createValidationError(\r\n              field.name,\r\n              `${field.label || field.name} does not match the required pattern`,\r\n            ),\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    return createValidationResponse(errors);\r\n  }\r\n}\r\n"],"names":["CollectionSchemaService","create","createDto","userId","existing","collectionSchemaModel","findOne","databaseId","Types","ObjectId","name","exec","BadRequestException","fieldNames","fields","map","f","uniqueNames","Set","length","size","schema","createdBy","version","save","findAll","paginationDto","page","limit","search","skip","query","$or","$regex","$options","displayName","description","data","total","Promise","all","find","sort","createdAt","countDocuments","totalPages","Math","ceil","findById","id","NotFoundException","toString","ForbiddenException","findByName","findByNamePublic","findAllSchemas","select","update","updateDto","updatedSchema","findByIdAndUpdate","new","remove","findByIdAndDelete","validateData","collectionName","errors","systemFields","field","includes","value","validation","required","undefined","push","createValidationError","label","actualType","isValidType","type","FieldType","STRING","TEXT","TEXTAREA","EMAIL","URL","RICH_TEXT","NUMBER","isNaN","BOOLEAN","CHECKBOX","DATE","DATETIME","Date","parse","ARRAY","MULTI_SELECT","Array","isArray","JSON","REFERENCE","isValid","SELECT","RADIO","FILE","IMAGE","enum","join","min","max","minLength","maxLength","pattern","regex","RegExp","test","createValidationResponse","validateDataPublic"],"mappings":"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"}