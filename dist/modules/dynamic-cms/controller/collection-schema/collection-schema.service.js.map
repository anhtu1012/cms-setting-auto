{"version":3,"sources":["../../../../../src/modules/dynamic-cms/controller/collection-schema/collection-schema.service.ts"],"sourcesContent":["import {\r\n  Injectable,\r\n  BadRequestException,\r\n  NotFoundException,\r\n  ForbiddenException,\r\n} from '@nestjs/common';\r\nimport { InjectModel } from '@nestjs/mongoose';\r\nimport { Model, Types } from 'mongoose';\r\nimport {\r\n  CollectionSchemaModel,\r\n  CollectionSchemaDocument,\r\n} from '../../schemas/collection-schema.schema';\r\nimport {\r\n  CreateCollectionSchemaDto,\r\n  UpdateCollectionSchemaDto,\r\n} from '../../dto/collection-schema.dto';\r\nimport {\r\n  PaginationDto,\r\n  PaginationResponse,\r\n} from '../../../../common/dto/pagination.dto';\r\nimport { FieldType } from '../../interfaces/field-types.interface';\r\nimport {\r\n  ValidationResponse,\r\n  ValidationError,\r\n  createValidationError,\r\n  createValidationResponse,\r\n} from '../../../../common/dto/validation.dto';\r\n\r\n@Injectable()\r\nexport class CollectionSchemaService {\r\n  constructor(\r\n    @InjectModel(CollectionSchemaModel.name)\r\n    private collectionSchemaModel: Model<CollectionSchemaDocument>,\r\n  ) {}\r\n\r\n  /**\r\n   * Tạo collection schema mới\r\n   */\r\n  async create(\r\n    createDto: CreateCollectionSchemaDto,\r\n    userId: string,\r\n  ): Promise<CollectionSchemaModel> {\r\n    // Kiểm tra xem collection name đã tồn tại trong database này chưa\r\n    const existing = await this.collectionSchemaModel\r\n      .findOne({\r\n        databaseId: new Types.ObjectId(createDto.databaseId),\r\n        name: createDto.name,\r\n      })\r\n      .exec();\r\n\r\n    if (existing) {\r\n      throw new BadRequestException(\r\n        `Collection with name \"${createDto.name}\" already exists in this database`,\r\n      );\r\n    }\r\n\r\n    // Validate field names không trùng nhau\r\n    const fieldNames = createDto.fields.map((f) => f.name);\r\n    const uniqueNames = new Set(fieldNames);\r\n    if (fieldNames.length !== uniqueNames.size) {\r\n      throw new BadRequestException('Field names must be unique');\r\n    }\r\n\r\n    // Tạo collection schema\r\n    const schema = new this.collectionSchemaModel({\r\n      ...createDto,\r\n      databaseId: new Types.ObjectId(createDto.databaseId),\r\n      userId: new Types.ObjectId(userId),\r\n      createdBy: userId,\r\n      version: 1,\r\n    });\r\n\r\n    return schema.save();\r\n  }\r\n\r\n  /**\r\n   * Lấy danh sách collection schemas của user trong database\r\n   */\r\n  async findAll(\r\n    paginationDto: PaginationDto,\r\n    userId: string,\r\n    databaseId?: string,\r\n  ): Promise<PaginationResponse<CollectionSchemaModel>> {\r\n    const { page = 1, limit = 10, search } = paginationDto;\r\n    const skip = (page - 1) * limit;\r\n\r\n    const query: any = { userId: new Types.ObjectId(userId) };\r\n\r\n    if (databaseId) {\r\n      query.databaseId = new Types.ObjectId(databaseId);\r\n    }\r\n\r\n    if (search) {\r\n      query.$or = [\r\n        { name: { $regex: search, $options: 'i' } },\r\n        { displayName: { $regex: search, $options: 'i' } },\r\n        { description: { $regex: search, $options: 'i' } },\r\n      ];\r\n    }\r\n\r\n    const [data, total] = await Promise.all([\r\n      this.collectionSchemaModel\r\n        .find(query)\r\n        .skip(skip)\r\n        .limit(limit)\r\n        .sort({ createdAt: -1 })\r\n        .exec(),\r\n      this.collectionSchemaModel.countDocuments(query).exec(),\r\n    ]);\r\n\r\n    return {\r\n      data,\r\n      total,\r\n      page,\r\n      limit,\r\n      totalPages: Math.ceil(total / limit),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Lấy collection schema theo ID và kiểm tra ownership\r\n   */\r\n  async findById(\r\n    id: string,\r\n    userId: string,\r\n  ): Promise<CollectionSchemaModel | null> {\r\n    const schema = await this.collectionSchemaModel.findById(id).exec();\r\n\r\n    if (!schema) {\r\n      throw new NotFoundException(\r\n        `Collection schema with id \"${id}\" not found`,\r\n      );\r\n    }\r\n\r\n    if (schema.userId.toString() !== userId) {\r\n      throw new ForbiddenException('You do not have access to this collection');\r\n    }\r\n\r\n    return schema;\r\n  }\r\n\r\n  /**\r\n   * Lấy collection schema theo name trong database của user (có check ownership)\r\n   */\r\n  async findByName(\r\n    name: string,\r\n    userId: string,\r\n    databaseId: string,\r\n  ): Promise<CollectionSchemaModel | null> {\r\n    return this.collectionSchemaModel\r\n      .findOne({\r\n        name,\r\n        userId: new Types.ObjectId(userId),\r\n        databaseId: new Types.ObjectId(databaseId),\r\n      })\r\n      .exec();\r\n  }\r\n\r\n  /**\r\n   * Lấy collection schema theo name trong database (không check ownership)\r\n   * Dùng cho public API - chỉ cần databaseId\r\n   */\r\n  async findByNamePublic(\r\n    name: string,\r\n    databaseId: string,\r\n  ): Promise<CollectionSchemaModel | null> {\r\n    // Validate ObjectId format\r\n    if (!Types.ObjectId.isValid(databaseId)) {\r\n      throw new BadRequestException(\r\n        `Invalid databaseId format: \"${databaseId}\". Must be a 24 character hex string.`,\r\n      );\r\n    }\r\n\r\n    return this.collectionSchemaModel\r\n      .findOne({\r\n        name,\r\n        databaseId: new Types.ObjectId(databaseId),\r\n      })\r\n      .exec();\r\n  }\r\n\r\n  /**\r\n   * Lấy tất cả collection schemas của user (không phân trang)\r\n   */\r\n  async findAllSchemas(\r\n    userId: string,\r\n    databaseId?: string,\r\n  ): Promise<CollectionSchemaModel[]> {\r\n    const query: any = { userId: new Types.ObjectId(userId) };\r\n\r\n    if (databaseId) {\r\n      query.databaseId = new Types.ObjectId(databaseId);\r\n    }\r\n\r\n    return this.collectionSchemaModel\r\n      .find(query)\r\n      .select('-fields')\r\n      .sort({ displayName: 1 })\r\n      .exec();\r\n  }\r\n\r\n  /**\r\n   * Cập nhật collection schema\r\n   */\r\n  async update(\r\n    id: string,\r\n    updateDto: UpdateCollectionSchemaDto,\r\n    userId: string,\r\n  ): Promise<CollectionSchemaModel | null> {\r\n    const schema = await this.collectionSchemaModel.findById(id).exec();\r\n\r\n    if (!schema) {\r\n      throw new NotFoundException(\r\n        `Collection schema with id \"${id}\" not found`,\r\n      );\r\n    }\r\n\r\n    // Check ownership\r\n    if (schema.userId.toString() !== userId) {\r\n      throw new ForbiddenException('You do not have access to this collection');\r\n    }\r\n\r\n    // Nếu update fields, validate field names\r\n    if (updateDto.fields) {\r\n      const fieldNames = updateDto.fields.map((f) => f.name);\r\n      const uniqueNames = new Set(fieldNames);\r\n      if (fieldNames.length !== uniqueNames.size) {\r\n        throw new BadRequestException('Field names must be unique');\r\n      }\r\n    }\r\n\r\n    // Tăng version khi update\r\n    const updatedSchema = await this.collectionSchemaModel\r\n      .findByIdAndUpdate(\r\n        id,\r\n        {\r\n          ...updateDto,\r\n          version: schema.version + 1,\r\n        },\r\n        { new: true },\r\n      )\r\n      .exec();\r\n\r\n    return updatedSchema;\r\n  }\r\n\r\n  /**\r\n   * Xóa collection schema\r\n   */\r\n  async remove(\r\n    id: string,\r\n    userId: string,\r\n  ): Promise<CollectionSchemaModel | null> {\r\n    const schema = await this.collectionSchemaModel.findById(id).exec();\r\n\r\n    if (!schema) {\r\n      throw new NotFoundException(\r\n        `Collection schema with id \"${id}\" not found`,\r\n      );\r\n    }\r\n\r\n    // Check ownership\r\n    if (schema.userId.toString() !== userId) {\r\n      throw new ForbiddenException('You do not have access to this collection');\r\n    }\r\n\r\n    // TODO: Kiểm tra xem có dữ liệu nào đang sử dụng schema này không\r\n    // Nếu có thì cần warning hoặc không cho xóa\r\n\r\n    return this.collectionSchemaModel.findByIdAndDelete(id).exec();\r\n  }\r\n\r\n  /**\r\n   * Validate dữ liệu theo schema\r\n   */\r\n  async validateData(\r\n    collectionName: string,\r\n    userId: string | null,\r\n    databaseId: string,\r\n    data: Record<string, any>,\r\n  ): Promise<ValidationResponse> {\r\n    const errors: ValidationError[] = [];\r\n\r\n    // Lấy schema\r\n    const schema = await this.findByName(collectionName, userId, databaseId);\r\n    if (!schema) {\r\n      throw new NotFoundException(\r\n        `Collection schema \"${collectionName}\" not found`,\r\n      );\r\n    }\r\n\r\n    // Danh sách các field tự động của hệ thống - không cần validate\r\n    const systemFields = ['id', '_id', 'createdAt', 'updatedAt', '__v'];\r\n\r\n    // Validate từng field\r\n    for (const field of schema.fields) {\r\n      // Bỏ qua các field hệ thống\r\n      if (systemFields.includes(field.name)) {\r\n        continue;\r\n      }\r\n\r\n      const value = data[field.name];\r\n      const validation = field.validation || {};\r\n\r\n      // Check required\r\n      if (\r\n        validation.required &&\r\n        (value === undefined || value === null || value === '')\r\n      ) {\r\n        errors.push(\r\n          createValidationError(\r\n            field.name,\r\n            `${field.label || field.name} is required`,\r\n          ),\r\n        );\r\n        continue;\r\n      }\r\n\r\n      // Nếu không có value và không required thì skip validation type\r\n      if (value === undefined || value === null) {\r\n        continue;\r\n      }\r\n\r\n      // Validate type\r\n      const actualType = typeof value;\r\n      let isValidType = false;\r\n\r\n      switch (field.type) {\r\n        case FieldType.STRING:\r\n        case FieldType.TEXT:\r\n        case FieldType.TEXTAREA:\r\n        case FieldType.EMAIL:\r\n        case FieldType.URL:\r\n        case FieldType.RICH_TEXT:\r\n          isValidType = actualType === 'string';\r\n          break;\r\n        case FieldType.NUMBER:\r\n          isValidType = actualType === 'number' && !isNaN(value);\r\n          break;\r\n        case FieldType.BOOLEAN:\r\n        case FieldType.CHECKBOX:\r\n          isValidType = actualType === 'boolean';\r\n          break;\r\n        case FieldType.DATE:\r\n        case FieldType.DATETIME:\r\n          isValidType = !isNaN(Date.parse(value));\r\n          break;\r\n        case FieldType.ARRAY:\r\n        case FieldType.MULTI_SELECT:\r\n          isValidType = Array.isArray(value);\r\n          break;\r\n        case FieldType.JSON:\r\n          isValidType = actualType === 'object' && !Array.isArray(value);\r\n          break;\r\n        case FieldType.REFERENCE:\r\n          // Reference có thể là ObjectId hoặc string\r\n          isValidType =\r\n            actualType === 'string' || Types.ObjectId.isValid(value);\r\n          break;\r\n        case FieldType.SELECT:\r\n        case FieldType.RADIO:\r\n          isValidType = actualType === 'string' || actualType === 'number';\r\n          break;\r\n        case FieldType.FILE:\r\n        case FieldType.IMAGE:\r\n          isValidType = actualType === 'string'; // URL string\r\n          break;\r\n        default:\r\n          isValidType = true; // Unknown types pass\r\n      }\r\n\r\n      if (!isValidType) {\r\n        errors.push(\r\n          createValidationError(\r\n            field.name,\r\n            `${field.label || field.name} must be of type ${field.type}, got ${actualType}`,\r\n          ),\r\n        );\r\n      }\r\n\r\n      // Validate enum\r\n      if (validation.enum && validation.enum.length > 0) {\r\n        if (!validation.enum.includes(value)) {\r\n          errors.push(\r\n            createValidationError(\r\n              field.name,\r\n              `${field.label || field.name} must be one of: ${validation.enum.join(', ')}`,\r\n            ),\r\n          );\r\n        }\r\n      }\r\n\r\n      // Validate min/max for numbers\r\n      if (field.type === FieldType.NUMBER && typeof value === 'number') {\r\n        if (validation.min !== undefined && value < validation.min) {\r\n          errors.push(\r\n            createValidationError(\r\n              field.name,\r\n              `${field.label || field.name} must be at least ${validation.min}`,\r\n            ),\r\n          );\r\n        }\r\n        if (validation.max !== undefined && value > validation.max) {\r\n          errors.push(\r\n            createValidationError(\r\n              field.name,\r\n              `${field.label || field.name} must be at most ${validation.max}`,\r\n            ),\r\n          );\r\n        }\r\n      }\r\n\r\n      // Validate minLength/maxLength for strings\r\n      if (\r\n        (field.type === FieldType.STRING ||\r\n          field.type === FieldType.TEXT ||\r\n          field.type === FieldType.TEXTAREA) &&\r\n        typeof value === 'string'\r\n      ) {\r\n        if (\r\n          validation.minLength !== undefined &&\r\n          value.length < validation.minLength\r\n        ) {\r\n          errors.push(\r\n            createValidationError(\r\n              field.name,\r\n              `${field.label || field.name} must be at least ${validation.minLength} characters`,\r\n            ),\r\n          );\r\n        }\r\n        if (\r\n          validation.maxLength !== undefined &&\r\n          value.length > validation.maxLength\r\n        ) {\r\n          errors.push(\r\n            createValidationError(\r\n              field.name,\r\n              `${field.label || field.name} must be at most ${validation.maxLength} characters`,\r\n            ),\r\n          );\r\n        }\r\n      }\r\n\r\n      // Validate pattern (regex)\r\n      if (validation.pattern && typeof value === 'string') {\r\n        const regex = new RegExp(validation.pattern);\r\n        if (!regex.test(value)) {\r\n          errors.push(\r\n            createValidationError(\r\n              field.name,\r\n              `${field.label || field.name} does not match the required pattern`,\r\n            ),\r\n          );\r\n        }\r\n      }\r\n\r\n      // TODO: Validate unique\r\n      // Cần inject DynamicDataModel để check uniqueness trong database\r\n    }\r\n\r\n    return createValidationResponse(errors);\r\n  }\r\n\r\n  /**\r\n   * Validate dữ liệu theo schema (public - không check ownership)\r\n   * Dùng cho dynamic-data public API\r\n   */\r\n  async validateDataPublic(\r\n    collectionName: string,\r\n    databaseId: string,\r\n    data: Record<string, any>,\r\n  ): Promise<ValidationResponse> {\r\n    const errors: ValidationError[] = [];\r\n\r\n    // Lấy schema (không check ownership)\r\n    const schema = await this.findByNamePublic(collectionName, databaseId);\r\n    if (!schema) {\r\n      throw new NotFoundException(\r\n        `Collection schema \"${collectionName}\" not found`,\r\n      );\r\n    }\r\n\r\n    // Danh sách các field tự động của hệ thống - không cần validate\r\n    const systemFields = ['id', '_id', 'createdAt', 'updatedAt', '__v'];\r\n\r\n    // Validate từng field\r\n    for (const field of schema.fields) {\r\n      // Bỏ qua các field hệ thống\r\n      if (systemFields.includes(field.name)) {\r\n        continue;\r\n      }\r\n\r\n      const value = data[field.name];\r\n      const validation = field.validation || {};\r\n\r\n      // Check required\r\n      if (\r\n        validation.required &&\r\n        (value === undefined || value === null || value === '')\r\n      ) {\r\n        errors.push(\r\n          createValidationError(\r\n            field.name,\r\n            `${field.label || field.name} is required`,\r\n          ),\r\n        );\r\n        continue; // Bỏ qua các validation khác nếu required fail\r\n      }\r\n\r\n      // Nếu value không có và không required thì skip validation\r\n      if (value === undefined || value === null) {\r\n        continue;\r\n      }\r\n\r\n      // Validate min/max for numbers\r\n      if (field.type === FieldType.NUMBER && typeof value === 'number') {\r\n        if (validation.min !== undefined && value < validation.min) {\r\n          errors.push(\r\n            createValidationError(\r\n              field.name,\r\n              `${field.label || field.name} must be at least ${validation.min}`,\r\n            ),\r\n          );\r\n        }\r\n        if (validation.max !== undefined && value > validation.max) {\r\n          errors.push(\r\n            createValidationError(\r\n              field.name,\r\n              `${field.label || field.name} must be at most ${validation.max}`,\r\n            ),\r\n          );\r\n        }\r\n      }\r\n\r\n      // Validate minLength/maxLength for strings\r\n      if (\r\n        (field.type === FieldType.STRING ||\r\n          field.type === FieldType.TEXT ||\r\n          field.type === FieldType.TEXTAREA) &&\r\n        typeof value === 'string'\r\n      ) {\r\n        if (\r\n          validation.minLength !== undefined &&\r\n          value.length < validation.minLength\r\n        ) {\r\n          errors.push(\r\n            createValidationError(\r\n              field.name,\r\n              `${field.label || field.name} must be at least ${validation.minLength} characters`,\r\n            ),\r\n          );\r\n        }\r\n        if (\r\n          validation.maxLength !== undefined &&\r\n          value.length > validation.maxLength\r\n        ) {\r\n          errors.push(\r\n            createValidationError(\r\n              field.name,\r\n              `${field.label || field.name} must be at most ${validation.maxLength} characters`,\r\n            ),\r\n          );\r\n        }\r\n      }\r\n\r\n      // Validate pattern (regex)\r\n      if (validation.pattern && typeof value === 'string') {\r\n        const regex = new RegExp(validation.pattern);\r\n        if (!regex.test(value)) {\r\n          errors.push(\r\n            createValidationError(\r\n              field.name,\r\n              `${field.label || field.name} does not match the required pattern`,\r\n            ),\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    return createValidationResponse(errors);\r\n  }\r\n}\r\n"],"names":["CollectionSchemaService","create","createDto","userId","existing","collectionSchemaModel","findOne","databaseId","Types","ObjectId","name","exec","BadRequestException","fieldNames","fields","map","f","uniqueNames","Set","length","size","schema","createdBy","version","save","findAll","paginationDto","page","limit","search","skip","query","$or","$regex","$options","displayName","description","data","total","Promise","all","find","sort","createdAt","countDocuments","totalPages","Math","ceil","findById","id","NotFoundException","toString","ForbiddenException","findByName","findByNamePublic","isValid","findAllSchemas","select","update","updateDto","updatedSchema","findByIdAndUpdate","new","remove","findByIdAndDelete","validateData","collectionName","errors","systemFields","field","includes","value","validation","required","undefined","push","createValidationError","label","actualType","isValidType","type","FieldType","STRING","TEXT","TEXTAREA","EMAIL","URL","RICH_TEXT","NUMBER","isNaN","BOOLEAN","CHECKBOX","DATE","DATETIME","Date","parse","ARRAY","MULTI_SELECT","Array","isArray","JSON","REFERENCE","SELECT","RADIO","FILE","IMAGE","enum","join","min","max","minLength","maxLength","pattern","regex","RegExp","test","createValidationResponse","validateDataPublic"],"mappings":"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"}