{"version":3,"sources":["../../../../src/modules/auth/handlers/register.handler.ts"],"sourcesContent":["import {\r\n  Injectable,\r\n  ConflictException,\r\n  BadRequestException,\r\n} from '@nestjs/common';\r\nimport { InjectModel } from '@nestjs/mongoose';\r\nimport { Model } from 'mongoose';\r\nimport * as bcrypt from 'bcrypt';\r\nimport { User, UserDocument } from '../../users/schemas/user.schema';\r\nimport { RegisterRequestDto } from '../dto/auth-request.dto';\r\n\r\n@Injectable()\r\nexport class RegisterHandler {\r\n  constructor(@InjectModel(User.name) private userModel: Model<UserDocument>) {}\r\n\r\n  async execute(registerDto: RegisterRequestDto) {\r\n    // Check if user exists\r\n    const existingUser = await this.userModel\r\n      .findOne({\r\n        $or: [{ email: registerDto.email }, { userName: registerDto.userName }],\r\n      })\r\n      .exec();\r\n\r\n    if (existingUser) {\r\n      if (existingUser.email === registerDto.email) {\r\n        throw new ConflictException('Email already exists');\r\n      }\r\n      if (existingUser.userName === registerDto.userName) {\r\n        throw new ConflictException('Username already exists');\r\n      }\r\n    }\r\n\r\n    // Hash password\r\n    const hashedPassword = await this.hashPassword(registerDto.password);\r\n\r\n    // Create user\r\n    const newUser = new this.userModel({\r\n      ...registerDto,\r\n      password: hashedPassword,\r\n      points: 0,\r\n      walletBalance: 0,\r\n      walletTransactions: [],\r\n      pointsHistory: [],\r\n    });\r\n\r\n    const savedUser = await newUser.save();\r\n\r\n    return {\r\n      message: 'User registered successfully',\r\n      userProfile: {\r\n        id: savedUser._id.toString(),\r\n        email: savedUser.email,\r\n        userName: savedUser.userName,\r\n        firstName: savedUser.firstName,\r\n        lastName: savedUser.lastName,\r\n        role: savedUser.role,\r\n        isActive: savedUser.isActive,\r\n        avatar: savedUser.avatar,\r\n        points: savedUser.points,\r\n        walletBalance: savedUser.walletBalance,\r\n        lastLogin: savedUser.lastLogin,\r\n      },\r\n    };\r\n  }\r\n\r\n  private async hashPassword(password: string): Promise<string> {\r\n    const saltRounds = 10;\r\n    return bcrypt.hash(password, saltRounds);\r\n  }\r\n}\r\n"],"names":["RegisterHandler","execute","registerDto","existingUser","userModel","findOne","$or","email","userName","exec","ConflictException","hashedPassword","hashPassword","password","newUser","points","walletBalance","walletTransactions","pointsHistory","savedUser","save","message","userProfile","id","_id","toString","firstName","lastName","role","isActive","avatar","lastLogin","saltRounds","bcrypt","hash","name"],"mappings":";;;;+BAYaA;;;eAAAA;;;wBARN;0BACqB;2BACN;gEACE;4BACW;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAI5B,IAAA,AAAMA,kBAAN,MAAMA;IAGX,MAAMC,QAAQC,WAA+B,EAAE;QAC7C,uBAAuB;QACvB,MAAMC,eAAe,MAAM,IAAI,CAACC,SAAS,CACtCC,OAAO,CAAC;YACPC,KAAK;gBAAC;oBAAEC,OAAOL,YAAYK,KAAK;gBAAC;gBAAG;oBAAEC,UAAUN,YAAYM,QAAQ;gBAAC;aAAE;QACzE,GACCC,IAAI;QAEP,IAAIN,cAAc;YAChB,IAAIA,aAAaI,KAAK,KAAKL,YAAYK,KAAK,EAAE;gBAC5C,MAAM,IAAIG,yBAAiB,CAAC;YAC9B;YACA,IAAIP,aAAaK,QAAQ,KAAKN,YAAYM,QAAQ,EAAE;gBAClD,MAAM,IAAIE,yBAAiB,CAAC;YAC9B;QACF;QAEA,gBAAgB;QAChB,MAAMC,iBAAiB,MAAM,IAAI,CAACC,YAAY,CAACV,YAAYW,QAAQ;QAEnE,cAAc;QACd,MAAMC,UAAU,IAAI,IAAI,CAACV,SAAS,CAAC;YACjC,GAAGF,WAAW;YACdW,UAAUF;YACVI,QAAQ;YACRC,eAAe;YACfC,oBAAoB,EAAE;YACtBC,eAAe,EAAE;QACnB;QAEA,MAAMC,YAAY,MAAML,QAAQM,IAAI;QAEpC,OAAO;YACLC,SAAS;YACTC,aAAa;gBACXC,IAAIJ,UAAUK,GAAG,CAACC,QAAQ;gBAC1BlB,OAAOY,UAAUZ,KAAK;gBACtBC,UAAUW,UAAUX,QAAQ;gBAC5BkB,WAAWP,UAAUO,SAAS;gBAC9BC,UAAUR,UAAUQ,QAAQ;gBAC5BC,MAAMT,UAAUS,IAAI;gBACpBC,UAAUV,UAAUU,QAAQ;gBAC5BC,QAAQX,UAAUW,MAAM;gBACxBf,QAAQI,UAAUJ,MAAM;gBACxBC,eAAeG,UAAUH,aAAa;gBACtCe,WAAWZ,UAAUY,SAAS;YAChC;QACF;IACF;IAEA,MAAcnB,aAAaC,QAAgB,EAAmB;QAC5D,MAAMmB,aAAa;QACnB,OAAOC,QAAOC,IAAI,CAACrB,UAAUmB;IAC/B;IAvDA,YAAY,AAAgC5B,SAA8B,CAAE;aAAhCA,YAAAA;IAAiC;AAwD/E;;;6DAxDgC+B"}